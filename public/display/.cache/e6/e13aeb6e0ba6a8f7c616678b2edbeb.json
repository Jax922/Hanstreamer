{"id":"node_modules/@tensorflow-models/body-segmentation/body_pix/impl/output_rendering_util.js","dependencies":[{"name":"/Users/shedong/Documents/dev/display/node_modules/@tensorflow-models/body-segmentation/body_pix/impl/output_rendering_util.js.map","includedInParent":true,"mtime":1701372084192},{"name":"/Users/shedong/Documents/dev/display/package.json","includedInParent":true,"mtime":1701373985473},{"name":"/Users/shedong/Documents/dev/display/.babelrc","includedInParent":true,"mtime":1701372126384},{"name":"./blur","loc":{"line":20,"column":21},"parent":"/Users/shedong/Documents/dev/display/node_modules/@tensorflow-models/body-segmentation/body_pix/impl/output_rendering_util.js","resolved":"/Users/shedong/Documents/dev/display/node_modules/@tensorflow-models/body-segmentation/body_pix/impl/blur.js"},{"name":"./util","loc":{"line":21,"column":21},"parent":"/Users/shedong/Documents/dev/display/node_modules/@tensorflow-models/body-segmentation/body_pix/impl/output_rendering_util.js","resolved":"/Users/shedong/Documents/dev/display/node_modules/@tensorflow-models/body-segmentation/body_pix/impl/util.js"}],"generated":{"js":"\"use strict\";\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.blurBodyPart = exports.drawBokehEffect = exports.drawPixelatedMask = exports.drawMask = exports.toColoredPartMask = exports.toMask = void 0;\nvar blur_1 = require(\"./blur\");\nvar util_1 = require(\"./util\");\nvar offScreenCanvases = {};\nfunction isSafari() {\n    return (/^((?!chrome|android).)*safari/i.test(navigator.userAgent));\n}\nfunction assertSameDimensions(_a, _b, nameA, nameB) {\n    var widthA = _a.width, heightA = _a.height;\n    var widthB = _b.width, heightB = _b.height;\n    if (widthA !== widthB || heightA !== heightB) {\n        throw new Error(\"error: dimensions must match. \" + nameA + \" has dimensions \" + widthA + \"x\" + heightA + \", \" + nameB + \" has dimensions \" + widthB + \"x\" + heightB);\n    }\n}\nfunction flipCanvasHorizontal(canvas) {\n    var ctx = canvas.getContext('2d');\n    ctx.scale(-1, 1);\n    ctx.translate(-canvas.width, 0);\n}\nfunction drawWithCompositing(ctx, image, compositeOperation) {\n    ctx.globalCompositeOperation = compositeOperation;\n    ctx.drawImage(image, 0, 0);\n}\nfunction createOffScreenCanvas() {\n    if (typeof document !== 'undefined') {\n        return document.createElement('canvas');\n    }\n    else if (typeof OffscreenCanvas !== 'undefined') {\n        return new OffscreenCanvas(0, 0);\n    }\n    else {\n        throw new Error('Cannot create a canvas in this context');\n    }\n}\nfunction ensureOffscreenCanvasCreated(id) {\n    if (!offScreenCanvases[id]) {\n        offScreenCanvases[id] = createOffScreenCanvas();\n    }\n    return offScreenCanvases[id];\n}\nfunction drawAndBlurImageOnCanvas(image, blurAmount, canvas) {\n    var height = image.height, width = image.width;\n    var ctx = canvas.getContext('2d');\n    canvas.width = width;\n    canvas.height = height;\n    ctx.clearRect(0, 0, width, height);\n    ctx.save();\n    if (isSafari()) {\n        (0, blur_1.cpuBlur)(canvas, image, blurAmount);\n    }\n    else {\n        // tslint:disable:no-any\n        ctx.filter = \"blur(\" + blurAmount + \"px)\";\n        ctx.drawImage(image, 0, 0, width, height);\n    }\n    ctx.restore();\n}\nfunction drawAndBlurImageOnOffScreenCanvas(image, blurAmount, offscreenCanvasName) {\n    var canvas = ensureOffscreenCanvasCreated(offscreenCanvasName);\n    if (blurAmount === 0) {\n        renderImageToCanvas(image, canvas);\n    }\n    else {\n        drawAndBlurImageOnCanvas(image, blurAmount, canvas);\n    }\n    return canvas;\n}\nfunction renderImageToCanvas(image, canvas) {\n    var width = image.width, height = image.height;\n    canvas.width = width;\n    canvas.height = height;\n    var ctx = canvas.getContext('2d');\n    ctx.drawImage(image, 0, 0, width, height);\n}\n/**\n * Draw an image on a canvas\n */\nfunction renderImageDataToCanvas(image, canvas) {\n    canvas.width = image.width;\n    canvas.height = image.height;\n    var ctx = canvas.getContext('2d');\n    ctx.putImageData(image, 0, 0);\n}\nfunction renderImageDataToOffScreenCanvas(image, canvasName) {\n    var canvas = ensureOffscreenCanvasCreated(canvasName);\n    renderImageDataToCanvas(image, canvas);\n    return canvas;\n}\n/**\n * Given the output from estimating multi-person segmentation, generates an\n * image with foreground and background color at each pixel determined by the\n * corresponding binary segmentation value at the pixel from the output.  In\n * other words, pixels where there is a person will be colored with foreground\n * color and where there is not a person will be colored with background color.\n *\n * @param personOrPartSegmentation The output from\n * `segmentPerson`, `segmentMultiPerson`,\n * `segmentPersonParts` or `segmentMultiPersonParts`. They can\n * be SemanticPersonSegmentation object, an array of PersonSegmentation object,\n * SemanticPartSegmentation object, or an array of PartSegmentation object.\n *\n * @param foreground Default to {r:0, g:0, b:0, a: 0}. The foreground color\n * (r,g,b,a) for visualizing pixels that belong to people.\n *\n * @param background Default to {r:0, g:0, b:0, a: 255}. The background color\n * (r,g,b,a) for visualizing pixels that don't belong to people.\n *\n * @param drawContour Default to false. Whether to draw the contour around each\n * person's segmentation mask or body part mask.\n *\n * @param foregroundIds Default to [1]. The integer values that represent\n * foreground. For person segmentation, 1 is the foreground. For body part\n * segmentation, it can be a subset of all body parts ids.\n *\n * @returns An ImageData with the same width and height of\n * all the PersonSegmentation in multiPersonSegmentation, with opacity and\n * transparency at each pixel determined by the corresponding binary\n * segmentation value at the pixel from the output.\n */\nfunction toMask(personOrPartSegmentation, foreground, background, drawContour, foregroundIds) {\n    if (foreground === void 0) { foreground = {\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 0\n    }; }\n    if (background === void 0) { background = {\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 255\n    }; }\n    if (drawContour === void 0) { drawContour = false; }\n    if (foregroundIds === void 0) { foregroundIds = [1]; }\n    if (Array.isArray(personOrPartSegmentation) &&\n        personOrPartSegmentation.length === 0) {\n        return null;\n    }\n    var multiPersonOrPartSegmentation;\n    if (!Array.isArray(personOrPartSegmentation)) {\n        multiPersonOrPartSegmentation = [personOrPartSegmentation];\n    }\n    else {\n        multiPersonOrPartSegmentation = personOrPartSegmentation;\n    }\n    var _a = multiPersonOrPartSegmentation[0], width = _a.width, height = _a.height;\n    var bytes = new Uint8ClampedArray(width * height * 4);\n    function drawStroke(bytes, row, column, width, radius, color) {\n        if (color === void 0) { color = { r: 0, g: 255, b: 255, a: 255 }; }\n        for (var i = -radius; i <= radius; i++) {\n            for (var j = -radius; j <= radius; j++) {\n                if (i !== 0 && j !== 0) {\n                    var n = (row + i) * width + (column + j);\n                    bytes[4 * n + 0] = color.r;\n                    bytes[4 * n + 1] = color.g;\n                    bytes[4 * n + 2] = color.b;\n                    bytes[4 * n + 3] = color.a;\n                }\n            }\n        }\n    }\n    function isSegmentationBoundary(segmentationData, row, column, width, foregroundIds, radius) {\n        if (foregroundIds === void 0) { foregroundIds = [1]; }\n        if (radius === void 0) { radius = 1; }\n        var numberBackgroundPixels = 0;\n        for (var i = -radius; i <= radius; i++) {\n            var _loop_2 = function (j) {\n                if (i !== 0 && j !== 0) {\n                    var n_1 = (row + i) * width + (column + j);\n                    if (!foregroundIds.some(function (id) { return id === segmentationData[n_1]; })) {\n                        numberBackgroundPixels += 1;\n                    }\n                }\n            };\n            for (var j = -radius; j <= radius; j++) {\n                _loop_2(j);\n            }\n        }\n        return numberBackgroundPixels > 0;\n    }\n    for (var i = 0; i < height; i += 1) {\n        var _loop_1 = function (j) {\n            var n = i * width + j;\n            bytes[4 * n + 0] = background.r;\n            bytes[4 * n + 1] = background.g;\n            bytes[4 * n + 2] = background.b;\n            bytes[4 * n + 3] = background.a;\n            var _loop_3 = function (k) {\n                if (foregroundIds.some(function (id) { return id === multiPersonOrPartSegmentation[k].data[n]; })) {\n                    bytes[4 * n] = foreground.r;\n                    bytes[4 * n + 1] = foreground.g;\n                    bytes[4 * n + 2] = foreground.b;\n                    bytes[4 * n + 3] = foreground.a;\n                    var isBoundary = isSegmentationBoundary(multiPersonOrPartSegmentation[k].data, i, j, width, foregroundIds);\n                    if (drawContour && i - 1 >= 0 && i + 1 < height && j - 1 >= 0 &&\n                        j + 1 < width && isBoundary) {\n                        drawStroke(bytes, i, j, width, 1);\n                    }\n                }\n            };\n            for (var k = 0; k < multiPersonOrPartSegmentation.length; k++) {\n                _loop_3(k);\n            }\n        };\n        for (var j = 0; j < width; j += 1) {\n            _loop_1(j);\n        }\n    }\n    return new ImageData(bytes, width, height);\n}\nexports.toMask = toMask;\nvar RAINBOW_PART_COLORS = [\n    [110, 64, 170], [143, 61, 178], [178, 60, 178], [210, 62, 167],\n    [238, 67, 149], [255, 78, 125], [255, 94, 99], [255, 115, 75],\n    [255, 140, 56], [239, 167, 47], [217, 194, 49], [194, 219, 64],\n    [175, 240, 91], [135, 245, 87], [96, 247, 96], [64, 243, 115],\n    [40, 234, 141], [28, 219, 169], [26, 199, 194], [33, 176, 213],\n    [47, 150, 224], [65, 125, 224], [84, 101, 214], [99, 81, 195]\n];\n/**\n * Given the output from person body part segmentation (or multi-person\n * instance body part segmentation) and an array of colors indexed by part id,\n * generates an image with the corresponding color for each part at each pixel,\n * and white pixels where there is no part.\n *\n * @param partSegmentation The output from segmentPersonParts\n * or segmentMultiPersonParts. The former is a SemanticPartSegmentation\n * object and later is an array of PartSegmentation object.\n *\n * @param partColors A multi-dimensional array of rgb colors indexed by\n * part id.  Must have 24 colors, one for every part.\n *\n * @returns An ImageData with the same width and height of all the element in\n * multiPersonPartSegmentation, with the corresponding color for each part at\n * each pixel, and black pixels where there is no part.\n */\nfunction toColoredPartMask(partSegmentation, partColors) {\n    if (partColors === void 0) { partColors = RAINBOW_PART_COLORS; }\n    if (Array.isArray(partSegmentation) && partSegmentation.length === 0) {\n        return null;\n    }\n    var multiPersonPartSegmentation;\n    if (!Array.isArray(partSegmentation)) {\n        multiPersonPartSegmentation = [partSegmentation];\n    }\n    else {\n        multiPersonPartSegmentation = partSegmentation;\n    }\n    var _a = multiPersonPartSegmentation[0], width = _a.width, height = _a.height;\n    var bytes = new Uint8ClampedArray(width * height * 4);\n    for (var i = 0; i < height * width; ++i) {\n        // invert mask.  Invert the segmentation mask.\n        var j = i * 4;\n        bytes[j + 0] = 255;\n        bytes[j + 1] = 255;\n        bytes[j + 2] = 255;\n        bytes[j + 3] = 255;\n        for (var k = 0; k < multiPersonPartSegmentation.length; k++) {\n            var partId = multiPersonPartSegmentation[k].data[i];\n            if (partId !== -1) {\n                var color = partColors[partId];\n                if (!color) {\n                    throw new Error(\"No color could be found for part id \" + partId);\n                }\n                bytes[j + 0] = color[0];\n                bytes[j + 1] = color[1];\n                bytes[j + 2] = color[2];\n                bytes[j + 3] = 255;\n            }\n        }\n    }\n    return new ImageData(bytes, width, height);\n}\nexports.toColoredPartMask = toColoredPartMask;\nvar CANVAS_NAMES = {\n    blurred: 'blurred',\n    blurredMask: 'blurred-mask',\n    mask: 'mask',\n    lowresPartMask: 'lowres-part-mask',\n};\n/**\n * Given an image and a maskImage of type ImageData, draws the image with the\n * mask on top of it onto a canvas.\n *\n * @param canvas The canvas to be drawn onto.\n *\n * @param image The original image to apply the mask to.\n *\n * @param maskImage An ImageData containing the mask.  Ideally this should be\n * generated by toMask or toColoredPartMask.\n *\n * @param maskOpacity The opacity of the mask when drawing it on top of the\n * image. Defaults to 0.7. Should be a float between 0 and 1.\n *\n * @param maskBlurAmount How many pixels to blur the mask by. Defaults to 0.\n * Should be an integer between 0 and 20.\n *\n * @param flipHorizontal If the result should be flipped horizontally.  Defaults\n * to false.\n */\nfunction drawMask(canvas, image, maskImage, maskOpacity, maskBlurAmount, flipHorizontal) {\n    if (maskOpacity === void 0) { maskOpacity = 0.7; }\n    if (maskBlurAmount === void 0) { maskBlurAmount = 0; }\n    if (flipHorizontal === void 0) { flipHorizontal = false; }\n    var _a = (0, util_1.getInputSize)(image), height = _a[0], width = _a[1];\n    canvas.width = width;\n    canvas.height = height;\n    var ctx = canvas.getContext('2d');\n    ctx.save();\n    if (flipHorizontal) {\n        flipCanvasHorizontal(canvas);\n    }\n    ctx.drawImage(image, 0, 0);\n    ctx.globalAlpha = maskOpacity;\n    if (maskImage) {\n        assertSameDimensions({ width: width, height: height }, maskImage, 'image', 'mask');\n        var mask = renderImageDataToOffScreenCanvas(maskImage, CANVAS_NAMES.mask);\n        var blurredMask = drawAndBlurImageOnOffScreenCanvas(mask, maskBlurAmount, CANVAS_NAMES.blurredMask);\n        ctx.drawImage(blurredMask, 0, 0, width, height);\n    }\n    ctx.restore();\n}\nexports.drawMask = drawMask;\n/**\n * Given an image and a maskImage of type ImageData, draws the image with the\n * pixelated mask on top of it onto a canvas.\n *\n * @param canvas The canvas to be drawn onto.\n *\n * @param image The original image to apply the mask to.\n *\n * @param maskImage An ImageData containing the mask.  Ideally this should be\n * generated by toColoredPartMask.\n *\n * @param maskOpacity The opacity of the mask when drawing it on top of the\n * image. Defaults to 0.7. Should be a float between 0 and 1.\n *\n * @param maskBlurAmount How many pixels to blur the mask by. Defaults to 0.\n * Should be an integer between 0 and 20.\n *\n * @param flipHorizontal If the result should be flipped horizontally.  Defaults\n * to false.\n *\n * @param pixelCellWidth The width of each pixel cell. Default to 10 px.\n */\nfunction drawPixelatedMask(canvas, image, maskImage, maskOpacity, maskBlurAmount, flipHorizontal, pixelCellWidth) {\n    if (maskOpacity === void 0) { maskOpacity = 0.7; }\n    if (maskBlurAmount === void 0) { maskBlurAmount = 0; }\n    if (flipHorizontal === void 0) { flipHorizontal = false; }\n    if (pixelCellWidth === void 0) { pixelCellWidth = 10.0; }\n    var _a = (0, util_1.getInputSize)(image), height = _a[0], width = _a[1];\n    assertSameDimensions({ width: width, height: height }, maskImage, 'image', 'mask');\n    var mask = renderImageDataToOffScreenCanvas(maskImage, CANVAS_NAMES.mask);\n    var blurredMask = drawAndBlurImageOnOffScreenCanvas(mask, maskBlurAmount, CANVAS_NAMES.blurredMask);\n    canvas.width = blurredMask.width;\n    canvas.height = blurredMask.height;\n    var ctx = canvas.getContext('2d');\n    ctx.save();\n    if (flipHorizontal) {\n        flipCanvasHorizontal(canvas);\n    }\n    var offscreenCanvas = ensureOffscreenCanvasCreated(CANVAS_NAMES.lowresPartMask);\n    var offscreenCanvasCtx = offscreenCanvas.getContext('2d');\n    offscreenCanvas.width = blurredMask.width * (1.0 / pixelCellWidth);\n    offscreenCanvas.height = blurredMask.height * (1.0 / pixelCellWidth);\n    offscreenCanvasCtx.drawImage(blurredMask, 0, 0, blurredMask.width, blurredMask.height, 0, 0, offscreenCanvas.width, offscreenCanvas.height);\n    ctx.imageSmoothingEnabled = false;\n    ctx.drawImage(offscreenCanvas, 0, 0, offscreenCanvas.width, offscreenCanvas.height, 0, 0, canvas.width, canvas.height);\n    // Draws vertical grid lines that are `pixelCellWidth` apart from each other.\n    for (var i = 0; i < offscreenCanvas.width; i++) {\n        ctx.beginPath();\n        ctx.strokeStyle = '#ffffff';\n        ctx.moveTo(pixelCellWidth * i, 0);\n        ctx.lineTo(pixelCellWidth * i, canvas.height);\n        ctx.stroke();\n    }\n    // Draws horizontal grid lines that are `pixelCellWidth` apart from each\n    // other.\n    for (var i = 0; i < offscreenCanvas.height; i++) {\n        ctx.beginPath();\n        ctx.strokeStyle = '#ffffff';\n        ctx.moveTo(0, pixelCellWidth * i);\n        ctx.lineTo(canvas.width, pixelCellWidth * i);\n        ctx.stroke();\n    }\n    ctx.globalAlpha = 1.0 - maskOpacity;\n    ctx.drawImage(image, 0, 0, blurredMask.width, blurredMask.height);\n    ctx.restore();\n}\nexports.drawPixelatedMask = drawPixelatedMask;\nfunction createPersonMask(multiPersonSegmentation, edgeBlurAmount) {\n    var backgroundMaskImage = toMask(multiPersonSegmentation, { r: 0, g: 0, b: 0, a: 255 }, { r: 0, g: 0, b: 0, a: 0 });\n    var backgroundMask = renderImageDataToOffScreenCanvas(backgroundMaskImage, CANVAS_NAMES.mask);\n    if (edgeBlurAmount === 0) {\n        return backgroundMask;\n    }\n    else {\n        return drawAndBlurImageOnOffScreenCanvas(backgroundMask, edgeBlurAmount, CANVAS_NAMES.blurredMask);\n    }\n}\n/**\n * Given a personSegmentation and an image, draws the image with its background\n * blurred onto the canvas.\n *\n * @param canvas The canvas to draw the background-blurred image onto.\n *\n * @param image The image to blur the background of and draw.\n *\n * @param personSegmentation A SemanticPersonSegmentation or an array of\n * PersonSegmentation object.\n *\n * @param backgroundBlurAmount How many pixels in the background blend into each\n * other.  Defaults to 3. Should be an integer between 1 and 20.\n *\n * @param edgeBlurAmount How many pixels to blur on the edge between the person\n * and the background by.  Defaults to 3. Should be an integer between 0 and 20.\n *\n * @param flipHorizontal If the output should be flipped horizontally.  Defaults\n * to false.\n */\nfunction drawBokehEffect(canvas, image, multiPersonSegmentation, backgroundBlurAmount, edgeBlurAmount, flipHorizontal) {\n    if (backgroundBlurAmount === void 0) { backgroundBlurAmount = 3; }\n    if (edgeBlurAmount === void 0) { edgeBlurAmount = 3; }\n    if (flipHorizontal === void 0) { flipHorizontal = false; }\n    var blurredImage = drawAndBlurImageOnOffScreenCanvas(image, backgroundBlurAmount, CANVAS_NAMES.blurred);\n    canvas.width = blurredImage.width;\n    canvas.height = blurredImage.height;\n    var ctx = canvas.getContext('2d');\n    if (Array.isArray(multiPersonSegmentation) &&\n        multiPersonSegmentation.length === 0) {\n        ctx.drawImage(blurredImage, 0, 0);\n        return;\n    }\n    var personMask = createPersonMask(multiPersonSegmentation, edgeBlurAmount);\n    ctx.save();\n    if (flipHorizontal) {\n        flipCanvasHorizontal(canvas);\n    }\n    // draw the original image on the final canvas\n    var _a = (0, util_1.getInputSize)(image), height = _a[0], width = _a[1];\n    ctx.drawImage(image, 0, 0, width, height);\n    // \"destination-in\" - \"The existing canvas content is kept where both the\n    // new shape and existing canvas content overlap. Everything else is made\n    // transparent.\"\n    // crop what's not the person using the mask from the original image\n    drawWithCompositing(ctx, personMask, 'destination-in');\n    // \"destination-over\" - \"The existing canvas content is kept where both the\n    // new shape and existing canvas content overlap. Everything else is made\n    // transparent.\"\n    // draw the blurred background on top of the original image where it doesn't\n    // overlap.\n    drawWithCompositing(ctx, blurredImage, 'destination-over');\n    ctx.restore();\n}\nexports.drawBokehEffect = drawBokehEffect;\nfunction createBodyPartMask(multiPersonPartSegmentation, bodyPartIdsToMask, edgeBlurAmount) {\n    var backgroundMaskImage = toMask(multiPersonPartSegmentation, { r: 0, g: 0, b: 0, a: 0 }, { r: 0, g: 0, b: 0, a: 255 }, true, bodyPartIdsToMask);\n    var backgroundMask = renderImageDataToOffScreenCanvas(backgroundMaskImage, CANVAS_NAMES.mask);\n    if (edgeBlurAmount === 0) {\n        return backgroundMask;\n    }\n    else {\n        return drawAndBlurImageOnOffScreenCanvas(backgroundMask, edgeBlurAmount, CANVAS_NAMES.blurredMask);\n    }\n}\n/**\n * Given a personSegmentation and an image, draws the image with its background\n * blurred onto the canvas.\n *\n * @param canvas The canvas to draw the background-blurred image onto.\n *\n * @param image The image to blur the background of and draw.\n *\n * @param partSegmentation A SemanticPartSegmentation or an array of\n * PartSegmentation object.\n *\n * @param bodyPartIdsToBlur Default to [0, 1] (left-face and right-face). An\n * array of body part ids to blur. Each must be one of the 24 body part ids.\n *\n * @param backgroundBlurAmount How many pixels in the background blend into each\n * other.  Defaults to 3. Should be an integer between 1 and 20.\n *\n * @param edgeBlurAmount How many pixels to blur on the edge between the person\n * and the background by.  Defaults to 3. Should be an integer between 0 and 20.\n *\n * @param flipHorizontal If the output should be flipped horizontally.  Defaults\n * to false.\n */\nfunction blurBodyPart(canvas, image, partSegmentation, bodyPartIdsToBlur, backgroundBlurAmount, edgeBlurAmount, flipHorizontal) {\n    if (bodyPartIdsToBlur === void 0) { bodyPartIdsToBlur = [0, 1]; }\n    if (backgroundBlurAmount === void 0) { backgroundBlurAmount = 3; }\n    if (edgeBlurAmount === void 0) { edgeBlurAmount = 3; }\n    if (flipHorizontal === void 0) { flipHorizontal = false; }\n    var blurredImage = drawAndBlurImageOnOffScreenCanvas(image, backgroundBlurAmount, CANVAS_NAMES.blurred);\n    canvas.width = blurredImage.width;\n    canvas.height = blurredImage.height;\n    var ctx = canvas.getContext('2d');\n    if (Array.isArray(partSegmentation) && partSegmentation.length === 0) {\n        ctx.drawImage(blurredImage, 0, 0);\n        return;\n    }\n    var bodyPartMask = createBodyPartMask(partSegmentation, bodyPartIdsToBlur, edgeBlurAmount);\n    ctx.save();\n    if (flipHorizontal) {\n        flipCanvasHorizontal(canvas);\n    }\n    // draw the original image on the final canvas\n    var _a = (0, util_1.getInputSize)(image), height = _a[0], width = _a[1];\n    ctx.drawImage(image, 0, 0, width, height);\n    // \"destination-in\" - \"The existing canvas content is kept where both the\n    // new shape and existing canvas content overlap. Everything else is made\n    // transparent.\"\n    // crop what's not the person using the mask from the original image\n    drawWithCompositing(ctx, bodyPartMask, 'destination-in');\n    // \"destination-over\" - \"The existing canvas content is kept where both the\n    // new shape and existing canvas content overlap. Everything else is made\n    // transparent.\"\n    // draw the blurred background on top of the original image where it doesn't\n    // overlap.\n    drawWithCompositing(ctx, blurredImage, 'destination-over');\n    ctx.restore();\n}\nexports.blurBodyPart = blurBodyPart;\n"},"sourceMaps":{"js":{"version":3,"file":"output_rendering_util.js","sourceRoot":"","sources":["../../../src/body_pix/impl/output_rendering_util.ts"],"names":[],"mappings":"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","sourcesContent":[null]}},"error":null,"hash":"467dd39b306833e0c48360436e8cda62","cacheData":{"env":{}}}