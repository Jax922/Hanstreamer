{"id":"node_modules/@tensorflow-models/body-segmentation/shared/calculators/render_util.js","dependencies":[{"name":"/Users/shedong/Documents/dev/Hanstreamer/public/display/node_modules/@tensorflow-models/body-segmentation/shared/calculators/render_util.js.map","includedInParent":true,"mtime":1701372084703},{"name":"/Users/shedong/Documents/dev/Hanstreamer/public/display/package.json","includedInParent":true,"mtime":1701375952532},{"name":"/Users/shedong/Documents/dev/Hanstreamer/public/display/.babelrc","includedInParent":true,"mtime":1701372126384},{"name":"@tensorflow/tfjs-core","loc":{"line":56,"column":17},"parent":"/Users/shedong/Documents/dev/Hanstreamer/public/display/node_modules/@tensorflow-models/body-segmentation/shared/calculators/render_util.js","resolved":"/Users/shedong/Documents/dev/Hanstreamer/public/display/node_modules/@tensorflow/tfjs-core/dist/index.js"}],"generated":{"js":"\"use strict\";\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.blurBodyPart = exports.drawBokehEffect = exports.drawPixelatedMask = exports.drawMask = exports.toColoredMask = exports.toBinaryMask = void 0;\nvar tf = require(\"@tensorflow/tfjs-core\");\nvar CANVAS_NAMES = {\n    blurred: 'blurred',\n    blurredMask: 'blurred-mask',\n    mask: 'mask',\n    lowresPartMask: 'lowres-part-mask',\n    drawImage: 'draw-image',\n};\nvar offScreenCanvases = {};\nfunction isSafari() {\n    return (/^((?!chrome|android).)*safari/i.test(navigator.userAgent));\n}\nfunction assertSameDimensions(_a, _b, nameA, nameB) {\n    var widthA = _a.width, heightA = _a.height;\n    var widthB = _b.width, heightB = _b.height;\n    if (widthA !== widthB || heightA !== heightB) {\n        throw new Error(\"error: dimensions must match. \" + nameA + \" has dimensions \" + widthA + \"x\" + heightA + \", \" + nameB + \" has dimensions \" + widthB + \"x\" + heightB);\n    }\n}\nfunction getSizeFromImageLikeElement(input) {\n    if ('offsetHeight' in input && input.offsetHeight !== 0 &&\n        'offsetWidth' in input && input.offsetWidth !== 0) {\n        return [input.offsetHeight, input.offsetWidth];\n    }\n    else if (input.height != null && input.width != null) {\n        return [input.height, input.width];\n    }\n    else {\n        throw new Error(\"HTMLImageElement must have height and width attributes set.\");\n    }\n}\nfunction getSizeFromVideoElement(input) {\n    if (input.hasAttribute('height') && input.hasAttribute('width')) {\n        // Prioritizes user specified height and width.\n        // We can't test the .height and .width properties directly,\n        // because they evaluate to 0 if unset.\n        return [input.height, input.width];\n    }\n    else {\n        return [input.videoHeight, input.videoWidth];\n    }\n}\nfunction getInputSize(input) {\n    if ((typeof (HTMLCanvasElement) !== 'undefined' &&\n        input instanceof HTMLCanvasElement) ||\n        (typeof (OffscreenCanvas) !== 'undefined' &&\n            input instanceof OffscreenCanvas) ||\n        (typeof (HTMLImageElement) !== 'undefined' &&\n            input instanceof HTMLImageElement)) {\n        return getSizeFromImageLikeElement(input);\n    }\n    else if (typeof (ImageData) !== 'undefined' && input instanceof ImageData) {\n        return [input.height, input.width];\n    }\n    else if (typeof (HTMLVideoElement) !== 'undefined' &&\n        input instanceof HTMLVideoElement) {\n        return getSizeFromVideoElement(input);\n    }\n    else if (input instanceof tf.Tensor) {\n        return [input.shape[0], input.shape[1]];\n    }\n    else {\n        throw new Error(\"error: Unknown input type: \" + input + \".\");\n    }\n}\nfunction createOffScreenCanvas() {\n    if (typeof document !== 'undefined') {\n        return document.createElement('canvas');\n    }\n    else if (typeof OffscreenCanvas !== 'undefined') {\n        return new OffscreenCanvas(0, 0);\n    }\n    else {\n        throw new Error('Cannot create a canvas in this context');\n    }\n}\nfunction ensureOffscreenCanvasCreated(id) {\n    if (!offScreenCanvases[id]) {\n        offScreenCanvases[id] = createOffScreenCanvas();\n    }\n    return offScreenCanvases[id];\n}\n/**\n * Draw image data on a canvas.\n */\nfunction renderImageDataToCanvas(image, canvas) {\n    canvas.width = image.width;\n    canvas.height = image.height;\n    var ctx = canvas.getContext('2d');\n    ctx.putImageData(image, 0, 0);\n}\nfunction renderImageDataToOffScreenCanvas(image, canvasName) {\n    var canvas = ensureOffscreenCanvasCreated(canvasName);\n    renderImageDataToCanvas(image, canvas);\n    return canvas;\n}\n/**\n * Draw image on a 2D rendering context.\n */\nfunction drawImage(ctx, image, dx, dy, dw, dh) {\n    return __awaiter(this, void 0, void 0, function () {\n        var pixels, _a, height, width;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    if (!(image instanceof tf.Tensor)) return [3 /*break*/, 2];\n                    return [4 /*yield*/, tf.browser.toPixels(image)];\n                case 1:\n                    pixels = _b.sent();\n                    _a = getInputSize(image), height = _a[0], width = _a[1];\n                    image = new ImageData(pixels, width, height);\n                    _b.label = 2;\n                case 2:\n                    if (image instanceof ImageData) {\n                        image = renderImageDataToOffScreenCanvas(image, CANVAS_NAMES.drawImage);\n                    }\n                    if (dw == null || dh == null) {\n                        ctx.drawImage(image, dx, dy);\n                    }\n                    else {\n                        ctx.drawImage(image, dx, dy, dw, dh);\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\n/**\n * Draw image on a canvas.\n */\nfunction renderImageToCanvas(image, canvas) {\n    return __awaiter(this, void 0, void 0, function () {\n        var _a, height, width, ctx;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    _a = getInputSize(image), height = _a[0], width = _a[1];\n                    canvas.width = width;\n                    canvas.height = height;\n                    ctx = canvas.getContext('2d');\n                    return [4 /*yield*/, drawImage(ctx, image, 0, 0, width, height)];\n                case 1:\n                    _b.sent();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction flipCanvasHorizontal(canvas) {\n    var ctx = canvas.getContext('2d');\n    ctx.scale(-1, 1);\n    ctx.translate(-canvas.width, 0);\n}\nfunction drawWithCompositing(ctx, image, compositeOperation) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    // TODO: Assert type 'compositeOperation as GlobalCompositeOperation' after\n                    // typescript update to 4.6.0 or later\n                    // tslint:disable-next-line: no-any\n                    ctx.globalCompositeOperation = compositeOperation;\n                    return [4 /*yield*/, drawImage(ctx, image, 0, 0)];\n                case 1:\n                    _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\n// method copied from bGlur in https://codepen.io/zhaojun/pen/zZmRQe\nfunction cpuBlur(canvas, image, blur) {\n    return __awaiter(this, void 0, void 0, function () {\n        var ctx, sum, delta, alphaLeft, step, y, x, weight, y, x;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    ctx = canvas.getContext('2d');\n                    sum = 0;\n                    delta = 5;\n                    alphaLeft = 1 / (2 * Math.PI * delta * delta);\n                    step = blur < 3 ? 1 : 2;\n                    for (y = -blur; y <= blur; y += step) {\n                        for (x = -blur; x <= blur; x += step) {\n                            weight = alphaLeft * Math.exp(-(x * x + y * y) / (2 * delta * delta));\n                            sum += weight;\n                        }\n                    }\n                    y = -blur;\n                    _a.label = 1;\n                case 1:\n                    if (!(y <= blur)) return [3 /*break*/, 6];\n                    x = -blur;\n                    _a.label = 2;\n                case 2:\n                    if (!(x <= blur)) return [3 /*break*/, 5];\n                    ctx.globalAlpha = alphaLeft *\n                        Math.exp(-(x * x + y * y) / (2 * delta * delta)) / sum * blur;\n                    return [4 /*yield*/, drawImage(ctx, image, x, y)];\n                case 3:\n                    _a.sent();\n                    _a.label = 4;\n                case 4:\n                    x += step;\n                    return [3 /*break*/, 2];\n                case 5:\n                    y += step;\n                    return [3 /*break*/, 1];\n                case 6:\n                    ctx.globalAlpha = 1;\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction drawAndBlurImageOnCanvas(image, blurAmount, canvas) {\n    return __awaiter(this, void 0, void 0, function () {\n        var _a, height, width, ctx;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    _a = getInputSize(image), height = _a[0], width = _a[1];\n                    ctx = canvas.getContext('2d');\n                    canvas.width = width;\n                    canvas.height = height;\n                    ctx.clearRect(0, 0, width, height);\n                    ctx.save();\n                    if (!isSafari()) return [3 /*break*/, 2];\n                    return [4 /*yield*/, cpuBlur(canvas, image, blurAmount)];\n                case 1:\n                    _b.sent();\n                    return [3 /*break*/, 4];\n                case 2:\n                    // tslint:disable:no-any\n                    ctx.filter = \"blur(\" + blurAmount + \"px)\";\n                    return [4 /*yield*/, drawImage(ctx, image, 0, 0, width, height)];\n                case 3:\n                    _b.sent();\n                    _b.label = 4;\n                case 4:\n                    ctx.restore();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction drawAndBlurImageOnOffScreenCanvas(image, blurAmount, offscreenCanvasName) {\n    return __awaiter(this, void 0, void 0, function () {\n        var canvas;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    canvas = ensureOffscreenCanvasCreated(offscreenCanvasName);\n                    if (!(blurAmount === 0)) return [3 /*break*/, 2];\n                    return [4 /*yield*/, renderImageToCanvas(image, canvas)];\n                case 1:\n                    _a.sent();\n                    return [3 /*break*/, 4];\n                case 2: return [4 /*yield*/, drawAndBlurImageOnCanvas(image, blurAmount, canvas)];\n                case 3:\n                    _a.sent();\n                    _a.label = 4;\n                case 4: return [2 /*return*/, canvas];\n            }\n        });\n    });\n}\nfunction drawStroke(bytes, row, column, width, radius, color) {\n    if (color === void 0) { color = {\n        r: 0,\n        g: 255,\n        b: 255,\n        a: 255\n    }; }\n    for (var i = -radius; i <= radius; i++) {\n        for (var j = -radius; j <= radius; j++) {\n            if (i !== 0 && j !== 0) {\n                var n = (row + i) * width + (column + j);\n                bytes[4 * n + 0] = color.r;\n                bytes[4 * n + 1] = color.g;\n                bytes[4 * n + 2] = color.b;\n                bytes[4 * n + 3] = color.a;\n            }\n        }\n    }\n}\nfunction isSegmentationBoundary(data, row, column, width, isForegroundId, alphaCutoff, radius) {\n    if (radius === void 0) { radius = 1; }\n    var numberBackgroundPixels = 0;\n    for (var i = -radius; i <= radius; i++) {\n        for (var j = -radius; j <= radius; j++) {\n            if (i !== 0 && j !== 0) {\n                var n = (row + i) * width + (column + j);\n                if (!isForegroundId[data[4 * n]] || data[4 * n + 3] < alphaCutoff) {\n                    numberBackgroundPixels += 1;\n                }\n            }\n        }\n    }\n    return numberBackgroundPixels > 0;\n}\n/**\n * Given a segmentation or array of segmentations, generates an\n * image with foreground and background color at each pixel determined by the\n * corresponding binary segmentation value at the pixel from the output.  In\n * other words, pixels where there is a person will be colored with foreground\n * color and where there is not a person will be colored with background color.\n *\n * @param segmentation Single segmentation or array of segmentations.\n *\n * @param foreground Default to {r:0, g:0, b:0, a: 0}. The foreground color\n * (r,g,b,a) for visualizing pixels that belong to people.\n *\n * @param background Default to {r:0, g:0, b:0, a: 255}. The background color\n * (r,g,b,a) for visualizing pixels that don't belong to people.\n *\n * @param drawContour Default to false. Whether to draw the contour around each\n * person's segmentation mask or body part mask.\n *\n * @param foregroundThreshold Default to 0.5. The minimum probability\n * to color a pixel as foreground rather than background. The alpha channel\n * integer values will be taken as the probabilities (for more information refer\n * to `Segmentation` type's documentation).\n *\n * @param foregroundMaskValues Default to all mask values. The red channel\n *     integer values that represent foreground (for more information refer to\n * `Segmentation` type's documentation).\n *\n * @returns An ImageData with the same width and height of\n * the input segmentations, with opacity and\n * transparency at each pixel determined by the corresponding binary\n * segmentation value at the pixel from the output.\n */\nfunction toBinaryMask(segmentation, foreground, background, drawContour, foregroundThreshold, foregroundMaskValues) {\n    if (foreground === void 0) { foreground = {\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 0\n    }; }\n    if (background === void 0) { background = {\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 255\n    }; }\n    if (drawContour === void 0) { drawContour = false; }\n    if (foregroundThreshold === void 0) { foregroundThreshold = 0.5; }\n    if (foregroundMaskValues === void 0) { foregroundMaskValues = Array.from(Array(256).keys()); }\n    return __awaiter(this, void 0, void 0, function () {\n        var segmentations, masks, _a, width, height, bytes, alphaCutoff, isForegroundId, i, j, n, _i, masks_1, mask;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    segmentations = !Array.isArray(segmentation) ? [segmentation] : segmentation;\n                    if (segmentations.length === 0) {\n                        return [2 /*return*/, null];\n                    }\n                    return [4 /*yield*/, Promise.all(segmentations.map(function (segmentation) { return segmentation.mask.toImageData(); }))];\n                case 1:\n                    masks = _b.sent();\n                    _a = masks[0], width = _a.width, height = _a.height;\n                    bytes = new Uint8ClampedArray(width * height * 4);\n                    alphaCutoff = Math.round(255 * foregroundThreshold);\n                    isForegroundId = new Array(256).fill(false);\n                    foregroundMaskValues.forEach(function (id) { return isForegroundId[id] = true; });\n                    for (i = 0; i < height; i++) {\n                        for (j = 0; j < width; j++) {\n                            n = i * width + j;\n                            bytes[4 * n + 0] = background.r;\n                            bytes[4 * n + 1] = background.g;\n                            bytes[4 * n + 2] = background.b;\n                            bytes[4 * n + 3] = background.a;\n                            for (_i = 0, masks_1 = masks; _i < masks_1.length; _i++) {\n                                mask = masks_1[_i];\n                                if (isForegroundId[mask.data[4 * n]] &&\n                                    mask.data[4 * n + 3] >= alphaCutoff) {\n                                    bytes[4 * n] = foreground.r;\n                                    bytes[4 * n + 1] = foreground.g;\n                                    bytes[4 * n + 2] = foreground.b;\n                                    bytes[4 * n + 3] = foreground.a;\n                                    if (drawContour && i - 1 >= 0 && i + 1 < height && j - 1 >= 0 &&\n                                        j + 1 < width &&\n                                        isSegmentationBoundary(mask.data, i, j, width, isForegroundId, alphaCutoff)) {\n                                        drawStroke(bytes, i, j, width, 1);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    return [2 /*return*/, new ImageData(bytes, width, height)];\n            }\n        });\n    });\n}\nexports.toBinaryMask = toBinaryMask;\n/**\n * Given a segmentation or array of segmentations, and a function mapping\n * the red pixel values (representing body part labels) to colours,\n * generates an image with the corresponding color for each part at each pixel,\n * and background color used where there is no part.\n *\n * @param segmentation Single segmentation or array of segmentations.\n *\n * @param maskValueToColor A function mapping red channel mask values to\n * colors to use in output image.\n *\n * @param background Default to {r:0, g:0, b:0, a: 255}. The background color\n * (r,g,b,a) for visualizing pixels that don't belong to people.\n *\n * @param foregroundThreshold Default to 0.5. The minimum probability\n * to color a pixel as foreground rather than background. The alpha channel\n * integer values will be taken as the probabilities (for more information refer\n * to `Segmentation` type's documentation).\n *\n * @returns An ImageData with the same width and height of input segmentations,\n * with the corresponding color for each part at each pixel, and background\n * pixels where there is no part.\n */\nfunction toColoredMask(segmentation, maskValueToColor, background, foregroundThreshold) {\n    if (background === void 0) { background = {\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 255\n    }; }\n    if (foregroundThreshold === void 0) { foregroundThreshold = 0.5; }\n    return __awaiter(this, void 0, void 0, function () {\n        var segmentations, masks, _a, width, height, bytes, alphaCutoff, i, j, _i, masks_2, mask, maskValue, color;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    segmentations = !Array.isArray(segmentation) ? [segmentation] : segmentation;\n                    if (segmentations.length === 0) {\n                        return [2 /*return*/, null];\n                    }\n                    return [4 /*yield*/, Promise.all(segmentations.map(function (segmentation) { return segmentation.mask.toImageData(); }))];\n                case 1:\n                    masks = _b.sent();\n                    _a = masks[0], width = _a.width, height = _a.height;\n                    bytes = new Uint8ClampedArray(width * height * 4);\n                    alphaCutoff = Math.round(255 * foregroundThreshold);\n                    for (i = 0; i < height * width; ++i) {\n                        j = i * 4;\n                        bytes[j + 0] = background.r;\n                        bytes[j + 1] = background.g;\n                        bytes[j + 2] = background.b;\n                        bytes[j + 3] = background.a;\n                        for (_i = 0, masks_2 = masks; _i < masks_2.length; _i++) {\n                            mask = masks_2[_i];\n                            if (mask.data[j + 3] >= alphaCutoff) {\n                                maskValue = mask.data[j];\n                                color = maskValueToColor(maskValue);\n                                bytes[j + 0] = color.r;\n                                bytes[j + 1] = color.g;\n                                bytes[j + 2] = color.b;\n                                bytes[j + 3] = color.a;\n                            }\n                        }\n                    }\n                    return [2 /*return*/, new ImageData(bytes, width, height)];\n            }\n        });\n    });\n}\nexports.toColoredMask = toColoredMask;\n/**\n * Given an image and a maskImage of type ImageData, draws the image with the\n * mask on top of it onto a canvas.\n *\n * @param canvas The canvas to be drawn onto.\n *\n * @param image The original image to apply the mask to.\n *\n * @param maskImage An ImageData containing the mask. Ideally this should be\n * generated by toBinaryMask or toColoredMask.\n *\n * @param maskOpacity The opacity of the mask when drawing it on top of the\n * image. Defaults to 0.7. Should be a float between 0 and 1.\n *\n * @param maskBlurAmount How many pixels to blur the mask by. Defaults to 0.\n * Should be an integer between 0 and 20.\n *\n * @param flipHorizontal If the result should be flipped horizontally.  Defaults\n * to false.\n */\nfunction drawMask(canvas, image, maskImage, maskOpacity, maskBlurAmount, flipHorizontal) {\n    if (maskOpacity === void 0) { maskOpacity = 0.7; }\n    if (maskBlurAmount === void 0) { maskBlurAmount = 0; }\n    if (flipHorizontal === void 0) { flipHorizontal = false; }\n    return __awaiter(this, void 0, void 0, function () {\n        var _a, height, width, ctx, mask, blurredMask;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    _a = getInputSize(image), height = _a[0], width = _a[1];\n                    canvas.width = width;\n                    canvas.height = height;\n                    ctx = canvas.getContext('2d');\n                    ctx.save();\n                    if (flipHorizontal) {\n                        flipCanvasHorizontal(canvas);\n                    }\n                    return [4 /*yield*/, drawImage(ctx, image, 0, 0)];\n                case 1:\n                    _b.sent();\n                    ctx.globalAlpha = maskOpacity;\n                    if (!maskImage) return [3 /*break*/, 3];\n                    assertSameDimensions({ width: width, height: height }, maskImage, 'image', 'mask');\n                    mask = renderImageDataToOffScreenCanvas(maskImage, CANVAS_NAMES.mask);\n                    return [4 /*yield*/, drawAndBlurImageOnOffScreenCanvas(mask, maskBlurAmount, CANVAS_NAMES.blurredMask)];\n                case 2:\n                    blurredMask = _b.sent();\n                    ctx.drawImage(blurredMask, 0, 0, width, height);\n                    _b.label = 3;\n                case 3:\n                    ctx.restore();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.drawMask = drawMask;\n/**\n * Given an image and a maskImage of type ImageData, draws the image with the\n * pixelated mask on top of it onto a canvas.\n *\n * @param canvas The canvas to be drawn onto.\n *\n * @param image The original image to apply the mask to.\n *\n * @param maskImage An ImageData containing the mask.  Ideally this should be\n * generated by toColoredmask.\n *\n * @param maskOpacity The opacity of the mask when drawing it on top of the\n * image. Defaults to 0.7. Should be a float between 0 and 1.\n *\n * @param maskBlurAmount How many pixels to blur the mask by. Defaults to 0.\n * Should be an integer between 0 and 20.\n *\n * @param flipHorizontal If the result should be flipped horizontally.  Defaults\n * to false.\n *\n * @param pixelCellWidth The width of each pixel cell. Default to 10 px.\n */\nfunction drawPixelatedMask(canvas, image, maskImage, maskOpacity, maskBlurAmount, flipHorizontal, pixelCellWidth) {\n    if (maskOpacity === void 0) { maskOpacity = 0.7; }\n    if (maskBlurAmount === void 0) { maskBlurAmount = 0; }\n    if (flipHorizontal === void 0) { flipHorizontal = false; }\n    if (pixelCellWidth === void 0) { pixelCellWidth = 10.0; }\n    return __awaiter(this, void 0, void 0, function () {\n        var _a, height, width, mask, blurredMask, ctx, offscreenCanvas, offscreenCanvasCtx, i, i;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    _a = getInputSize(image), height = _a[0], width = _a[1];\n                    assertSameDimensions({ width: width, height: height }, maskImage, 'image', 'mask');\n                    mask = renderImageDataToOffScreenCanvas(maskImage, CANVAS_NAMES.mask);\n                    return [4 /*yield*/, drawAndBlurImageOnOffScreenCanvas(mask, maskBlurAmount, CANVAS_NAMES.blurredMask)];\n                case 1:\n                    blurredMask = _b.sent();\n                    canvas.width = blurredMask.width;\n                    canvas.height = blurredMask.height;\n                    ctx = canvas.getContext('2d');\n                    ctx.save();\n                    if (flipHorizontal) {\n                        flipCanvasHorizontal(canvas);\n                    }\n                    offscreenCanvas = ensureOffscreenCanvasCreated(CANVAS_NAMES.lowresPartMask);\n                    offscreenCanvasCtx = offscreenCanvas.getContext('2d');\n                    offscreenCanvas.width = blurredMask.width * (1.0 / pixelCellWidth);\n                    offscreenCanvas.height = blurredMask.height * (1.0 / pixelCellWidth);\n                    offscreenCanvasCtx.drawImage(blurredMask, 0, 0, blurredMask.width, blurredMask.height, 0, 0, offscreenCanvas.width, offscreenCanvas.height);\n                    ctx.imageSmoothingEnabled = false;\n                    ctx.drawImage(offscreenCanvas, 0, 0, offscreenCanvas.width, offscreenCanvas.height, 0, 0, canvas.width, canvas.height);\n                    // Draws vertical grid lines that are `pixelCellWidth` apart from each other.\n                    for (i = 0; i < offscreenCanvas.width; i++) {\n                        ctx.beginPath();\n                        ctx.strokeStyle = '#ffffff';\n                        ctx.moveTo(pixelCellWidth * i, 0);\n                        ctx.lineTo(pixelCellWidth * i, canvas.height);\n                        ctx.stroke();\n                    }\n                    // Draws horizontal grid lines that are `pixelCellWidth` apart from each\n                    // other.\n                    for (i = 0; i < offscreenCanvas.height; i++) {\n                        ctx.beginPath();\n                        ctx.strokeStyle = '#ffffff';\n                        ctx.moveTo(0, pixelCellWidth * i);\n                        ctx.lineTo(canvas.width, pixelCellWidth * i);\n                        ctx.stroke();\n                    }\n                    ctx.globalAlpha = 1.0 - maskOpacity;\n                    return [4 /*yield*/, drawImage(ctx, image, 0, 0, blurredMask.width, blurredMask.height)];\n                case 2:\n                    _b.sent();\n                    ctx.restore();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.drawPixelatedMask = drawPixelatedMask;\nfunction createPersonMask(segmentation, foregroundThreshold, edgeBlurAmount) {\n    return __awaiter(this, void 0, void 0, function () {\n        var backgroundMaskImage, backgroundMask;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, toBinaryMask(segmentation, { r: 0, g: 0, b: 0, a: 255 }, { r: 0, g: 0, b: 0, a: 0 }, false, foregroundThreshold)];\n                case 1:\n                    backgroundMaskImage = _a.sent();\n                    backgroundMask = renderImageDataToOffScreenCanvas(backgroundMaskImage, CANVAS_NAMES.mask);\n                    if (edgeBlurAmount === 0) {\n                        return [2 /*return*/, backgroundMask];\n                    }\n                    else {\n                        return [2 /*return*/, drawAndBlurImageOnOffScreenCanvas(backgroundMask, edgeBlurAmount, CANVAS_NAMES.blurredMask)];\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\n/**\n * Given a segmentation or array of segmentations, and an image, draws the image\n * with its background blurred onto the canvas.\n *\n * @param canvas The canvas to draw the background-blurred image onto.\n *\n * @param image The image to blur the background of and draw.\n *\n * @param segmentation Single segmentation or array of segmentations.\n *\n * @param foregroundThreshold Default to 0.5. The minimum probability\n * to color a pixel as foreground rather than background. The alpha channel\n * integer values will be taken as the probabilities (for more information refer\n * to `Segmentation` type's documentation).\n *\n * @param backgroundBlurAmount How many pixels in the background blend into each\n * other.  Defaults to 3. Should be an integer between 1 and 20.\n *\n * @param edgeBlurAmount How many pixels to blur on the edge between the person\n * and the background by.  Defaults to 3. Should be an integer between 0 and 20.\n *\n * @param flipHorizontal If the output should be flipped horizontally.  Defaults\n * to false.\n */\nfunction drawBokehEffect(canvas, image, segmentation, foregroundThreshold, backgroundBlurAmount, edgeBlurAmount, flipHorizontal) {\n    if (foregroundThreshold === void 0) { foregroundThreshold = 0.5; }\n    if (backgroundBlurAmount === void 0) { backgroundBlurAmount = 3; }\n    if (edgeBlurAmount === void 0) { edgeBlurAmount = 3; }\n    if (flipHorizontal === void 0) { flipHorizontal = false; }\n    return __awaiter(this, void 0, void 0, function () {\n        var blurredImage, ctx, personMask, _a, height, width;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0: return [4 /*yield*/, drawAndBlurImageOnOffScreenCanvas(image, backgroundBlurAmount, CANVAS_NAMES.blurred)];\n                case 1:\n                    blurredImage = _b.sent();\n                    canvas.width = blurredImage.width;\n                    canvas.height = blurredImage.height;\n                    ctx = canvas.getContext('2d');\n                    if (Array.isArray(segmentation) && segmentation.length === 0) {\n                        ctx.drawImage(blurredImage, 0, 0);\n                        return [2 /*return*/];\n                    }\n                    return [4 /*yield*/, createPersonMask(segmentation, foregroundThreshold, edgeBlurAmount)];\n                case 2:\n                    personMask = _b.sent();\n                    ctx.save();\n                    if (flipHorizontal) {\n                        flipCanvasHorizontal(canvas);\n                    }\n                    _a = getInputSize(image), height = _a[0], width = _a[1];\n                    return [4 /*yield*/, drawImage(ctx, image, 0, 0, width, height)];\n                case 3:\n                    _b.sent();\n                    // \"destination-in\" - \"The existing canvas content is kept where both the\n                    // new shape and existing canvas content overlap. Everything else is made\n                    // transparent.\"\n                    // crop what's not the person using the mask from the original image\n                    return [4 /*yield*/, drawWithCompositing(ctx, personMask, 'destination-in')];\n                case 4:\n                    // \"destination-in\" - \"The existing canvas content is kept where both the\n                    // new shape and existing canvas content overlap. Everything else is made\n                    // transparent.\"\n                    // crop what's not the person using the mask from the original image\n                    _b.sent();\n                    // \"destination-over\" - \"The existing canvas content is kept where both the\n                    // new shape and existing canvas content overlap. Everything else is made\n                    // transparent.\"\n                    // draw the blurred background on top of the original image where it doesn't\n                    // overlap.\n                    return [4 /*yield*/, drawWithCompositing(ctx, blurredImage, 'destination-over')];\n                case 5:\n                    // \"destination-over\" - \"The existing canvas content is kept where both the\n                    // new shape and existing canvas content overlap. Everything else is made\n                    // transparent.\"\n                    // draw the blurred background on top of the original image where it doesn't\n                    // overlap.\n                    _b.sent();\n                    ctx.restore();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.drawBokehEffect = drawBokehEffect;\nfunction createBodyPartMask(segmentation, maskValuesToBlur, foregroundThreshold, edgeBlurAmount) {\n    return __awaiter(this, void 0, void 0, function () {\n        var backgroundMaskImage, backgroundMask;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, toBinaryMask(segmentation, { r: 0, g: 0, b: 0, a: 0 }, { r: 0, g: 0, b: 0, a: 255 }, true, foregroundThreshold, maskValuesToBlur)];\n                case 1:\n                    backgroundMaskImage = _a.sent();\n                    backgroundMask = renderImageDataToOffScreenCanvas(backgroundMaskImage, CANVAS_NAMES.mask);\n                    if (edgeBlurAmount === 0) {\n                        return [2 /*return*/, backgroundMask];\n                    }\n                    else {\n                        return [2 /*return*/, drawAndBlurImageOnOffScreenCanvas(backgroundMask, edgeBlurAmount, CANVAS_NAMES.blurredMask)];\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\n/**\n * Given a personSegmentation and an image, draws the image with its background\n * blurred onto the canvas.\n *\n * @param canvas The canvas to draw the background-blurred image onto.\n *\n * @param image The image to blur the background of and draw.\n *\n * @param segmentation Single segmentation or array of segmentations.\n *\n * @param maskValuesToBlur An array of red channel mask values to blur\n *     (representing different body parts, refer to `Segmentation` interface\n * docs for more details).\n *\n * @param foregroundThreshold Default to 0.5. The minimum probability\n * to color a pixel as foreground rather than background. The alpha channel\n * integer values will be taken as the probabilities (for more information refer\n * to `Segmentation` type's documentation).\n *\n * @param backgroundBlurAmount How many pixels in the background blend into each\n * other.  Defaults to 3. Should be an integer between 1 and 20.\n *\n * @param edgeBlurAmount How many pixels to blur on the edge between the person\n * and the background by.  Defaults to 3. Should be an integer between 0 and 20.\n *\n * @param flipHorizontal If the output should be flipped horizontally.  Defaults\n * to false.\n */\nfunction blurBodyPart(canvas, image, segmentation, maskValuesToBlur, foregroundThreshold, backgroundBlurAmount, edgeBlurAmount, flipHorizontal) {\n    if (foregroundThreshold === void 0) { foregroundThreshold = 0.5; }\n    if (backgroundBlurAmount === void 0) { backgroundBlurAmount = 3; }\n    if (edgeBlurAmount === void 0) { edgeBlurAmount = 3; }\n    if (flipHorizontal === void 0) { flipHorizontal = false; }\n    return __awaiter(this, void 0, void 0, function () {\n        var blurredImage, ctx, bodyPartMask, _a, height, width;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0: return [4 /*yield*/, drawAndBlurImageOnOffScreenCanvas(image, backgroundBlurAmount, CANVAS_NAMES.blurred)];\n                case 1:\n                    blurredImage = _b.sent();\n                    canvas.width = blurredImage.width;\n                    canvas.height = blurredImage.height;\n                    ctx = canvas.getContext('2d');\n                    if (Array.isArray(segmentation) && segmentation.length === 0) {\n                        ctx.drawImage(blurredImage, 0, 0);\n                        return [2 /*return*/];\n                    }\n                    return [4 /*yield*/, createBodyPartMask(segmentation, maskValuesToBlur, foregroundThreshold, edgeBlurAmount)];\n                case 2:\n                    bodyPartMask = _b.sent();\n                    ctx.save();\n                    if (flipHorizontal) {\n                        flipCanvasHorizontal(canvas);\n                    }\n                    _a = getInputSize(image), height = _a[0], width = _a[1];\n                    return [4 /*yield*/, drawImage(ctx, image, 0, 0, width, height)];\n                case 3:\n                    _b.sent();\n                    // \"destination-in\" - \"The existing canvas content is kept where both the\n                    // new shape and existing canvas content overlap. Everything else is made\n                    // transparent.\"\n                    // crop what's not the person using the mask from the original image\n                    return [4 /*yield*/, drawWithCompositing(ctx, bodyPartMask, 'destination-in')];\n                case 4:\n                    // \"destination-in\" - \"The existing canvas content is kept where both the\n                    // new shape and existing canvas content overlap. Everything else is made\n                    // transparent.\"\n                    // crop what's not the person using the mask from the original image\n                    _b.sent();\n                    // \"destination-over\" - \"The existing canvas content is kept where both the\n                    // new shape and existing canvas content overlap. Everything else is made\n                    // transparent.\"\n                    // draw the blurred background on top of the original image where it doesn't\n                    // overlap.\n                    return [4 /*yield*/, drawWithCompositing(ctx, blurredImage, 'destination-over')];\n                case 5:\n                    // \"destination-over\" - \"The existing canvas content is kept where both the\n                    // new shape and existing canvas content overlap. Everything else is made\n                    // transparent.\"\n                    // draw the blurred background on top of the original image where it doesn't\n                    // overlap.\n                    _b.sent();\n                    ctx.restore();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.blurBodyPart = blurBodyPart;\n"},"sourceMaps":{"js":{"version":3,"file":"render_util.js","sourceRoot":"","sources":["../../../src/shared/calculators/render_util.ts"],"names":[],"mappings":"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","sourcesContent":[null]}},"error":null,"hash":"60ded38c473235283a1467b8abfdf229","cacheData":{"env":{}}}